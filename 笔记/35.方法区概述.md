## 运行时数据区结构

从线程共享与否的角度看

![image-20230427051302057](image/35.%E6%96%B9%E6%B3%95%E5%8C%BA%E6%A6%82%E8%BF%B0/image-20230427051302057.png)

## 栈、堆、方法区的交互关系

![image-20230427051742099](image/35.%E6%96%B9%E6%B3%95%E5%8C%BA%E6%A6%82%E8%BF%B0/image-20230427051742099.png)



## 方法区的理解

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。

所以，<font color="orange">方法区看作是一块独立于Java堆的内存空间。</font>

- 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。

- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。

- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。

- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：`java.lang.OutOfMemoryError: PermGen space` 或者`java.lang.OutOfMemoryError: Metaspace` 

- - <font color="orange">加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类</font>

- 关闭JVM就会释放这个区域的内存。



## HotSpot中方法区的演进

在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。

本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。

现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过`-XX:MaxPermsize`上限）

而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替

![image-20230427054456614](image/35.%E6%96%B9%E6%B3%95%E5%8C%BA%E6%A6%82%E8%BF%B0/image-20230427054456614.png)

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<font color="orange">元空间不在虚拟机设置的内存中，而是使用本地内存</font>

永久代、元空间二者并不只是名字变了，内部结构也调整了

根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常