![第10章_对象的实例化](image/Untitled/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg)



## 字节码的角度看待对象的创建

```java
public class ObjectTest {
    public static void main(String[] args) {
        Object o = new Object();
    }
}
```

```java
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
         7: astore_1
         8: return
```



```java
stack=2, locals=2, args_size=1
```

操作数栈是2，本地变量表2个，参数1个



```java
0: new           #2                  // class java/lang/Object
```

调用new，首先会去判断这个Object这个类是否已经加载了，如果没有加载，就要用类的加载器去加载
加载完成后，类的信息这样的参数会放到方法区，在堆中开辟好对应的空间，并且赋值好默认的值，例如boolean是false，int是0等等



```java
3: dup
```

复制，相当于有2个引用，都指向堆空间的实体，操作数栈中一个是用于赋值操作，一个是句柄，去调用相关的方法【了解】



```java
4: invokespecial #1                  // Method java/lang/Object."<init>":()V
```

调用构造器



ps：static代码块和构造器，static代码块先执行



## 从创建对象的步骤

### 1. 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。

如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。



### 2. 为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小

#### 如果内存规整：采用指针碰撞分配内存

- 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
- <font color="orange">意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</font>
- 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
- 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域

#### 如果内存不规整：采用空闲列表（Free List）

- 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
- <font color="orange">意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</font>
- 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
- 标记清除算法清理过后的堆内存，就会存在很多内存碎片。



### 3. 处理并发问题

采用CAS失败重试、区域加锁保证更新的原子性

每个线程预先分配一块TLAB：通过设置 `-XX:+UseTLAB`参数来设定【默认开启】



### 4. 初始化分配到的内存

所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用【说白了就是默认初始化】

给对象属性赋值的顺序：

1. 属性的默认值初始化
2. 显式初始化 / 代码块初始化（并列关系，谁先谁后看代码编写的顺序）【第6步执行】
3. 构造器初始化【第6步执行】



### 5. 设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。



### 6. 执行init方法进行初始化【构造器】

1. 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
2. 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。