## 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？

原因就在于应用程序所应对的<font color="cyan">业务越来越庞大、复杂，用户越来越多</font>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

与此同时，为了适应现在<font color="cyan">不断扩大的内存和不断增加的处理器数量</font>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。

<font color="cyan">官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</font>



## 为什么名字叫 Garbage First(G1)呢？

因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。

G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color="cyan">每次根据允许的收集时间，优先回收价值最大的Region</font>。

由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<font color="cyan">主要针对配备多核CPU及大容量内存的机器</font>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

在JDK1.7版本正式启用，移除了Experimenta1的标识，<font color="cyan">是JDK9以后的默认垃圾回收器</font>，取代了CMS回收器以及Parallel+Parallel Old组合。<font color="cyan">被Oracle官方称为“全功能的垃圾收集器”</font>。

与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用<font color="cyan">-XX:+UseG1GC</font>来启用。



## G1回收器的特点（优势）

与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：

### 并行与并发兼具

- 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW

- 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

### 分代收集

- 从分代上看，<font color="cyan">G1依然属于分代型垃圾回收器</font>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但<font color="cyan">从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</font>。

- 将<font color="cyan">堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</font>。

- 和之前的各类回收器不同，它<font color="cyan">同时兼顾年轻代和老年代</font>。对比其他回收器，或者工作在年轻代，或者工作在老年代；

G1不再是下面的内存结构

![image-20230503191322626](image/73.G1%E5%9B%9E%E6%94%B6%E5%99%A8/image-20230503191322626.png)

而是可以这样的

![image-20230503191411466](image/73.G1%E5%9B%9E%E6%94%B6%E5%99%A8/image-20230503191411466.png)

### 空间整合

- CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理

- G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<font color="cyan">Region之间是复制算法</font>，但整体上实际可看作是<font color="cyan">标记-压缩（Mark-Compact）算法</font>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

### 可预测的停顿时间模型（即：软实时soft real-time）

这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

- 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。

- G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color="cyan">每次根据允许的收集时间，优先回收价值最大的Region</font>。保证了G1收集器在有限的时间内可以<font color="cyan">获取尽可能高的收集效率</font>。

- 相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿时间，但是最差情况要好很多。



## G1垃圾收集器的缺点

相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。

从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。



## G1回收器的参数设置

<font color="cyan">-XX:+UseG1GC</font>：手动指定使用G1垃圾收集器执行内存回收任务

<font color="cyan">-XX:G1HeapRegionSize</font> 设置每个Region的大小。值是2的幂【1,2,4,8,16,32】，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。【-XX:G1HeapRegionSize=2m】

<font color="cyan">-XX:MaxGCPauseMillis</font> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度）

<font color="cyan">-XX:+ParallelGCThread</font> 设置STW时GC线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count > 8时，ParallelGCThreads 也会大于8）

<font color="cyan">-XX:ConcGCThreads</font> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。

<font color="cyan">-XX:InitiatingHeapOccupancyPercent</font> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。



## G1收集器的常见操作步骤

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

- 第一步：开启G1垃圾收集器

- 第二步：设置堆的最大内存

- 第三步：设置最大的停顿时间

G1中提供了三种垃圾回收模式：Young GC、Mixed GC和Full GC，在不同的条件下被触发。



## G1收集器的适用场景

<font color="cyan">面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</font>

<font color="cyan">最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案</font>；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。

用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：

- 超过50%的Java堆被活动数据占用；

- 对象分配频率或年代提升频率变化很大；

- GC停顿时间过长（长于0.5至1秒）

HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而<font color="cyan">G1 GC可以采用应用线程承担后台运行的GC工作</font>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。



## 分区Region：化整为零

使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过`-XX:G1HeapRegionSize`设定。<font color="cyan">所有的Region大小相同，且在JVM生命周期内不会被改变</font>。

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

![a5e91275-9f8c-4ea8-a34e-e20d3624a88a](image/73.G1%E5%9B%9E%E6%94%B6%E5%99%A8/a5e91275-9f8c-4ea8-a34e-e20d3624a88a.png)

一个region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。

G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果<font color="cyan">超过1.5个region，就放到H</font>。

设置H的原因：
对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<font color="cyan">如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。</font>为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

每个Region都是通过指针碰撞来分配空间【TLAB是为每个线程开辟的一小块独立的空间】

![image-20230503194308968](image/73.G1%E5%9B%9E%E6%94%B6%E5%99%A8/image-20230503194308968.png)