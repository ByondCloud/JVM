## 标记-清除算法（Mark-Sweep）

标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。

### 执行过程

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

-  标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 【非垃圾对象】

-  清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 

![第14章_标记-清除算法](image/61.%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg)

在有引用的对象头上添加一个标记，然后回收掉没有标记的对象

### 缺点

- 标记清除算法的效率不算高

- 在进行GC的时候，需要停止整个应用程序，用户体验较差

- 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表

### 何为清除？

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。



## 复制（Copying）算法

为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。

### 核心思想

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

![ee7a67ee-d092-4bd8-91a4-c0b75fb99a5c](image/61.%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5/ee7a67ee-d092-4bd8-91a4-c0b75fb99a5c.png)

### 优点

- 没有标记和清除过程，实现简单，运行高效

- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

### 缺点

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。

- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小

### 特别的

<font color="orange">如果系统中的垃圾对象很多，复制算法就不会很理想。</font>复制算法需要复制的存活对象数量并不会太大，或者说非常低才行

### 应用场景

在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。【新生代对象大多都是朝生夕死，因此适合复制算法】

![cb77f7b0-763a-41b3-af69-c0e32da56590](image/61.%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5/cb77f7b0-763a-41b3-af69-c0e32da56590.png)



## 标记-压缩（整理）算法

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<font color="orange">基于老年代垃圾回收的特性，需要使用其他的算法</font>。

标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。

1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。

### 执行过程

1.  第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 

2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 
3. 之后，清理边界外所有的空间。 

![1d2df46e-b7a2-4cb2-81cb-d41110838ae8](image/61.%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5/1d2df46e-b7a2-4cb2-81cb-d41110838ae8.png)

标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<font color="orange">标记-清除-压缩（Mark-Sweep-Compact）算法</font>。

二者的本质差异在于标记-清除算法是一种非移动式的回收算法，<font color="orange">标记-压缩是移动式的</font>。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

### 优点

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。

- 消除了复制算法当中，内存减半的高额代价。

### 缺点

- 从效率上来说，标记-整理算法要低于复制算法。

- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址

- 移动过程中，需要全程暂停用户应用程序。即：STW



## 小结

|              | Mark-Sweep         | Mark-Compact     | Copying                               |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。

而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段

难道就没有一种最优算法吗？回答：无，没有最好的算法，只有最合适的算法。