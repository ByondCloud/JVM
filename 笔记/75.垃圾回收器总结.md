截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。

| 垃圾收集器   | 分类           | 作用位置             | 使用算法                | 特点         | 适用场景                             |
| ------------ | -------------- | -------------------- | ----------------------- | ------------ | ------------------------------------ |
| Serial       | 串行运行       | 作用于新生代         | 复制算法                | 响应速度优先 | 适用于单CPU环境下的client模式        |
| ParNew       | 并行运行       | 作用于新生代         | 复制算法                | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用   |
| Parallel     | 并行运行       | 作用于新生代         | 复制算法                | 吞吐量优先   | 适用于后台运算而不需要太多交互的场景 |
| Serial Old   | 串行运行       | 作用于老年代         | 标记-压缩算法           | 响应速度优先 | 适用于单CPU环境下的Client模式        |
| Parallel Old | 并行运行       | 作用于老年代         | 标记-压缩算法           | 吞吐量优先   | 适用于后台运算而不需要太多交互的场景 |
| CMS          | 并发运行       | 作用于老年代         | 标记-清除算法           | 响应速度优先 | 适用于互联网或B／S业务               |
| G1           | 并发、并行运行 | 作用于新生代、老年代 | 标记-压缩算法、复制算法 | 响应速度优先 | 面向服务端应用                       |

GC发展阶段：Serial => Parallel（并行）=> CMS（并发）=> G1 => ZGC

## 垃圾回收器组合【JDK14】

### ![第17章_垃圾收集器组合](image/75.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93/%E7%AC%AC17%E7%AB%A0_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.jpg)

1.  两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1; 

2.  其中Serial Old作为CMS出现＂`Concurrent Mode Failure`＂失败的后备预案。 

3.  （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial＋CMS、ParNew＋Serial old这两个组合声明为Deprecated（JEP 173），并在JDK 9中 完全取消了这些组合的支持（JEP214），即：移除。

4.  （绿色虚线）JDK 14中：弃用ParallelScavenge和SeriaOold GC组合(JEP 366) 

5.  （蓝色虚框）JDK 14中：删除CMS垃圾回收器（JEP 363） 



## 怎么选择垃圾回收器

Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。

怎么选择垃圾收集器？

1.  优先调整堆的大小让JVM自适应完成。 

2.  如果内存小于100M，使用串行收集器 

3.  如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 

4.  如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 

5.  如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器
   官方推荐G1，性能高。<font color="cyan">现在互联网的项目，基本都是使用G1</font>。 

最后需要明确一个观点：

1. 没有最好的收集器，更没有万能的收集

2. 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器



## 面试

https://www.nowcoder.com/discuss/353157331598909440

对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：

-  垃圾收集的算法有哪些？如何判断一个对象是否可以回收？ 

-  垃圾收集器工作的基本流程。 

另外，大家需要多关注垃圾回收器这一章的各种常用的参数