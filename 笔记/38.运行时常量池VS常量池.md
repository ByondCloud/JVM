![c46442c3-a805-4224-a521-3bef46055bb6](image/38.%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0VS%E5%B8%B8%E9%87%8F%E6%B1%A0/c46442c3-a805-4224-a521-3bef46055bb6.png)

- 方法区，内部包含了运行时常量池

- 字节码文件，内部包含了常量池

- 要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。

- 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。

官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html

![image-20230427080242894](image/38.%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0VS%E5%B8%B8%E9%87%8F%E6%B1%A0/image-20230427080242894.png)

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用

## 为什么需要常量池？

一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。

```java
public class SimpleClass {
    public void sayHello() {
        System.out.println("hello");
    }
}
```

![image-20230427080646460](image/38.%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0VS%E5%B8%B8%E9%87%8F%E6%B1%A0/image-20230427080646460.png)

虽然只有213字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。

这样我们就不用把整个类都放到字节码文件中，而是通过常量池中的符号引用，去调用实际的类就可以了

### 小结

常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。



## 运行时常量池

- 运行时常量池（Runtime Constant Pool）是方法区的一部分。

- 常量池表（Constant Pool Table）是Class文件的一部分，<font color="orange">用于存放编译期生成的各种字面量与符号引用</font>，这部分内容将在类加载后存放到方法区的运行时常量池中。

- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。

- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。

- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<font color="orange">此时不再是常量池中的符号地址了，这里换为真实地址</font>。

- 运行时常量池，相对于Class文件常量池的另一重要特征是：<font color="orange">具备动态性</font>。

- 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。

- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。



## 小结

我们在class文件中可以看到常量池，这个是JIT编译之后的结果，这个class文件中的常量池并不会真正的存储对象，而是通过符号引用的方式存储他们，通过类加载子系统，将这一部分保存进了方法区中的运行时常量池中，这个运行时常量池就不会保存符号地址了，而是对象的真实地址