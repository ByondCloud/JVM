## java代码的执行分类

- 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 

-  第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 

HotSpot VM是目前市面上高性能虚拟机的代表作之一。它<font color="orange">采用解释器与即时编译器并存的架构。</font>在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。

在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。



## JIT那么快，为什么还要保留解释器？

有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？
<font color="cyan">比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行</font>。

首先明确： 
<font color="orange">当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。</font> 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。

所以： 
<font color="cyan">尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点</font>，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<font color="orange">当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</font>

同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。
就是JIT把解释器当备胎了，如果JIT优化不成，就用解释器



## HotSpot JVM执行方式

当虚拟机启动的时候，<font color="orange">解释器可以首先发挥作用</font>，而不必等待即时编译器全部编译完成再执行，这样可以<font color="orange">省去许多不必要的编译时间</font>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<font color="orange">将有价值的字节码编译为本地机器指令</font>，以换取更高的程序执行效率。



## 案例

注意解释执行与编译执行在线上环境微妙的辩证关系。<font color="orange">机器在热机状态可以承受的负载要大于冷机状态</font>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。

在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。

曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队

![a948568f-073b-43ef-9545-2647efefc333](image/50.JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/a948568f-073b-43ef-9545-2647efefc333.png)

## JIT的概念

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；

也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）
把字节码转变成机器码的过程。

还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）
直接把.java文件编译成本地机器代码的过程。

-  前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 

-  JIT编译器：HotSpot VM的C1、C2编译器。 

-  AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 



## 热点代码及探测技术

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<font color="orange">执行的频率</font>而定。关于那些需要被编译为本地代码的字节码，也被称之为<font color="orange">“热点代码”</font>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<font color="orange">深度优化</font>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

<font color="orange">一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</font>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为<font color="orange">栈上替换</font>，或简称为<font color="orange">OSR（On Stack Replacement）编译</font>。

一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<font color="orange">热点探测功能</font>。

<font color="orange">目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</font>

采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法<font color="orange">调用计数器（Invocation Counter）</font>和<font color="orange">回边计数器（Back Edge Counter）</font>。

- 方法调用计数器用于统计方法的调用次数

- 回边计数器则用于统计循环体执行的循环次数

<img src="image/50.JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/image-20230429094854856.png" alt="image-20230429094854856" style="zoom:67%;" />



### 方法调用计数器

这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。

这个阀值可以通过虚拟机参数 <font color="cyan">-XX:CompileThreshold</font>来人为设定。

当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

 <img src="image/50.JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_方法调用计数器" style="zoom: 50%;" />



### 回边计数器

它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。

 <img src="image/50.JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_回边计数器" style="zoom:50%;" />



## 热度衰减

如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<font color="orange">一段时间之内方法被调用的次数</font>。当超过<font color="orange">一定的时间限度</font>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<font color="orange">减少一半</font>，这个过程称为<font color="orange">方法调用计数器热度的衰减（Counter Decay）</font>，而这段时间就称为此<font color="orange">方法统计的半衰周期（Counter Half Life Time）</font>

进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <font color="cyan">-XX:-UseCounterDecay</font>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。

另外，可以使用<font color="cyan">-XX:CounterHalfLifeTime</font>参数设置半衰周期的时间，单位是秒。



## HotSpotVM 可以设置程序执行方法

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：

- `-Xint`：完全采用解释器模式执行程序；

- `-Xcomp`：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行

- `-Xmixed`：采用解释器+即时编译器的混合模式共同执行程序。

![image-20230429101304079](image/50.JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/image-20230429101304079.png)

或者修改VM选项

### 测试用例

```none
# vm参数
-Xint    # 花费的时间为：3628
-Xcomp   # 花费的时间为：252
-Xmixed  # 花费的时间为：246
```

```java
public class IntCompTest {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        testPrimeNumber(1000000); // 在server下JIT编译是10000次
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));
    }
    public static void testPrimeNumber(int count){
        for (int i = 0; i < count; i++) {
            //计算100以内的质数
            label:for(int j = 2;j <= 100;j++){
                for(int k = 2;k <= Math.sqrt(j);k++){
                    if(j % k == 0){
                        continue label;
                    }
                }
                //System.out.println(j);
            }
        }
    }
}
```



## HotSpot VM中JIT分类

在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

1. -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
   - C1编译器会对字节码进行<font color="orange">简单和可靠的优化，耗时短，以达到更快的编译速度</font>。
2. -server：指定Java虚拟机运行在server模式下，并使用C2编译器。
   - C2进行<font color="orange">耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</font>

PS：<font color="orange">默认64位的JDK就是Server，设置-client无效</font>



### C1和C2编译器不同的优化策略

1. 在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。
   - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
   - 去虚拟化：对唯一的实现类进行内联
   - 冗余消除：在运行期间把一些不会执行的代码折叠掉
2. C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：
   - 标量替换：用标量值代替聚合对象的属性值
   - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
   - 同步消除：清除同步操作，通常指synchronized
   - 之前讲的时候默认大家都是64位，因此没有强调，这个只有server才会生效

### 分层编译策略

分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。

不过在Java7版本之后，一旦开发人员在程序中显式指定命令<font color="cyan">-server</font>时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。

总结

1. 一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高
2. C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器



## Graal编译器【了解】

与C1、C2同一层次，概念的编译器

- 自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器

- 编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）

- 目前，带着实验状态标签，需要使用开关参数去激活才能使用

  -XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler

## AOT编译器【了解】

和JIT并列的概念

1. jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）

2. Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。

3. 所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是**在程序的运行过程中**，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，**在程序运行之前**，便将字节码转换为机器码的过程。

   .java -> .class -> (使用jaotc) -> .so



最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验

缺点：

- 破坏了 java “ 一次编译，到处运行”的理念，必须为每个不同的硬件，OS编译对应的发行包

- 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。

- 还需要继续优化中，最初只支持Linux X64 java base