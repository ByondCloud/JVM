

![第12章_理解中间过程](image/49.%E8%A7%A3%E9%87%8A%E5%99%A8/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E8%BF%87%E7%A8%8B.jpg)

## 解释器概念

JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。

解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 



## 解释器分类

1. 在Java的发展历史里，一共有两套解释执行器，即<font color="orange">古老的字节码解释器</font>和现在普遍使用的<font color="orange">模板解释器</font>
   - 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
   - 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
2. 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。
   - Interpreter模块：实现了解释器的核心功能
   - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令



## 解释器现状

1. 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于<font color="orange">解释器执行已经沦落为低效的代名词</font>，并且时常被一些C/C++程序员所调侃。
2. 为了解决这个问题，JVM平台支持一种叫作即时编译的技术【JIT】。即时编译的目的是避免函数被解释执行，而是<font color="orange">将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</font>，这种方式可以使执行效率大幅度提升。
3. 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。

